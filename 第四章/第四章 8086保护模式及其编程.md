# 第四章 8086保护模式及其编程

## 4.2 保护模式内存管理 ~ 4.4 分页机制

内容好多，概念理解一下，留一点印象，需要再回来翻翻，下次翻看可以带几个问题来看。

1、为什么要用内存？简单理解，CPU只能跑主存储器中的数据。  
2、虚拟地址面向对象是谁？程序员  
3、虚拟地址有什么用？方便程序员编写大型程序。  
4、虚拟地址，分段机制，线性地址，页面机制，物理地址，真实主存储器，虚拟存储系统之间的关系？  
虚拟地址寻址范围一般很大(虚拟地址范围=16K*4G=64T，乘法得到的地址是二维地址)，所以方便程序员开发程序。可是二维地址不方便硬件操作，所以需要用分段机制将二维地址转回一维地址（一个32bit的地址），即用分段机制将虚拟地址转换成线性地址。此时，如果不用分页机制和虚拟存储系统，就要拿4G的真实主存储器来装这些线性地址内容，那个时候这么大的主存储器不科学啊，所以就将线性地址分成一块块4K的小内存块，然后按照一定的规则（分页机制）将它们放到另外一个地址空间，也就是物理地址（寻址空间4G），再结合一下虚拟存储系统。就是说，当我想运行某个虚拟地址里面程序的时候，就将它当前映射的4K物理地址内容丢到主存储器里面跑，假设主存储器只有4K，那么这时候想继续跑下去就要跑到磁盘把下一个4K的内存块读出来，然后继续跑，这个过程就是虚拟存储系统在作用，让使用者以为自己有很多的主存储空间。  

参考链接：http://www.cnblogs.com/jack204/archive/2012/07/19/2599706.html

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/1.png)

- 当访问一个比实际存储器大的物理地址时候，需要用到虚拟存储技术:  
虚拟地址->分段机制->线性地址->分页机制->物理地址->虚拟存储技术->磁盘  

- 如果仅使用分段地址转换，那么存储在物理内存中的一个数据结构将包含所有成分。但如果使用了分页，那么一个数据结构就可以一部分存在物理内存一部分存在磁盘中。

----------

总结几个实例，有助理解。

1、 在任务A中，用汇编访问虚拟地址 (CS可见部分):1234，那么会发生什么事情呢？

CPU或者操作系统首先会将“CS可见部分（也就是段选择符）”取出来，找到段选择符中TI部分对应的LDT或GDT表，然后再通过段选择符中的索引部分在上述的LDT或GDT表中找出对应的段描述符，然后段描述符指出虚拟地址(CS可见部分):1234对应在线性地址中的位置，然后分页机制会将这个线性地址的前10bit用来索引页目录表，在页目录表中找到对应的目录项，通过查看页表项中的P标志位，看看映射的物理地址是否存在，存在就将其页表项提供的20bit基地址和线性地址的低12bit偏移地址合并起来得出物理地址，若不存在就先跑到磁盘去读出来，然后将上述的分页机制跑多一遍。

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/4.png)

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/5.png)

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/6.png)

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/7.png)

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/8.png)


2、在任务A中，访问虚拟地址1234:5678，然后切换到任务B中，访问虚拟地址1234:5678，会发生什么事情呢？

在切换之前的操作和问题1的答案大同小异，然后当CPU从运行任务A切换到任务B的时候，LDT里面的内容就会被CPU或者操作系统改成任务B的映射关系，然后CPU或者操作系统通过段选择符的索引在改变后的LDT上面找到的段描述符，肯定就和之前任务A找到的不一样啦，导致任务B虽然与任务A用的虚拟地址是一样的，可是映射出来的线性地址不一样了。这样程序员写程序时候，在不同任务都能操作同一个虚拟地址，可是互相不影响。

## 4.5 保护

- 当程序对错误内存空间执行了一次非期望的引用，保护机制可以组织这种操作并报告此类事件。

### 4.5.1 段级保护

参考这个，很好很厉害：http://www.cnblogs.com/wanghj-dz/p/3987599.html

### 4.5.5 组合页级和段级保护

- 段级保护启动时候，页级保护只能在它的基础上再加一些保护，而不能抹掉原来的保护功能。

## 4.6 中断和异常处理

- 中断和异常是指明系统、处理器或当前执行程序（或任务）的某处出现一个事件，该事件需要处理器进行处理。

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/3.png)

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/2.png)

假设被中断的任务处于低特权级，而外部中断处理函数是个高特权级的非一致性代码段。那么当发生外部中断时候，CPU系统总线收到一个中断向量号（0~255），然后将这个中断向量号*8得到一个在IDT上的索引号，然后在IDT中找出对应的门描述符，然后再用门描述符中的的段选择符在GDT或LDT中找到对应的段描述符，最后和IDT中门描述符的偏移值进行合并，得出线性地址。要是上述过程都通过了保护机制，而不发生错误的话，说明这次切换能够进行，由于是从低特权级到高特权级的非一致性程序段，CPU就会将DPL覆盖原来的CPL，会引发堆栈切换。所以首先要进行堆栈切换，然后再进行交换控制权。从DPL中，我们可以知道外部中断处理函数的特权级，然后就能在被中断任务的TSS中找出对应特权级的堆栈指针，先将当前的堆栈的指针临时保存起来，然后用TSS中找出的堆栈指针刷新堆栈寄存器。然后把刚刚临时保存的堆栈指针压入新栈，接着CPU又继续压了一堆信息进去新堆栈，最后把当前的CS：EIP的信息也压进去新栈。然后就可以交换控制权了，也就是开始运行外部中断函数的代码段，刚开始运行时候，外部中断的代码段可能会修改CS、DS等寄存器，可是堆栈用的还是刚刚被中断任务的TSS里面找出的堆栈指针开辟的堆栈空间。所以当需要返回被中断的任务时候用这个新堆栈就可以了，因为当时的堆栈和CS等寄存器信息都在这个新堆栈中。
