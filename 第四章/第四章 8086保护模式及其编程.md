# 第四章 8086保护模式及其编程

## 4.2 保护模式内存管理 ~ 4.4 分页机制

内容好多，概念理解一下，留一点印象，需要再回来翻翻，下次翻看可以带几个问题来看。

1、为什么要用内存？简单理解，CPU只能跑主存储器中的数据。  
2、虚拟地址面向对象是谁？程序员  
3、虚拟地址有什么用？方便程序员编写大型程序。  
4、虚拟地址，分段机制，线性地址，页面机制，物理地址，真实主存储器，虚拟存储系统之间的关系？  
虚拟地址寻址范围一般很大(虚拟地址范围=16K*4G=64T，乘法得到的地址是二维地址)，所以方便程序员开发程序。可是二维地址不方便硬件操作，所以需要用分段机制将二维地址转回一维地址（一个32bit的地址），即用分段机制将虚拟地址转换成线性地址。此时，如果不用分页机制和虚拟存储系统，就要拿4G的真实主存储器来装这些线性地址内容，那个时候这么大的主存储器不科学啊，所以就将线性地址分成一块块4K的小内存块，然后按照一定的规则（分页机制）将它们放到另外一个地址空间，也就是物理地址（寻址空间4G），再结合一下虚拟存储系统。就是说，当我想运行某个虚拟地址里面程序的时候，就将它当前映射的4K物理地址内容丢到主存储器里面跑，假设主存储器只有4K，那么这时候想继续跑下去就要跑到磁盘把下一个4K的内存块读出来，然后继续跑，这个过程就是虚拟存储系统在作用，让使用者以为自己有很多的主存储空间。  

参考链接：http://www.cnblogs.com/jack204/archive/2012/07/19/2599706.html

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/1.png)

- 当访问一个比实际存储器大的物理地址时候，需要用到虚拟存储技术:  
虚拟地址->分段机制->线性地址->分页机制->物理地址->虚拟存储技术->磁盘  

- 如果仅使用分段地址转换，那么存储在物理内存中的一个数据结构将包含所有成分。但如果使用了分页，那么一个数据结构就可以一部分存在物理内存一部分存在磁盘中。

----------

总结几个实例，有助理解。

1、 在任务A中，用汇编访问虚拟地址 (CS可见部分):1234，那么会发生什么事情呢？

CPU或者操作系统首先会将“CS可见部分（也就是段选择符）”取出来，找到段选择符中TI部分对应的LDT或GDT表，然后再通过段选择符中的索引部分在上述的LDT或GDT表中找出对应的段描述符，然后段描述符指出虚拟地址(CS可见部分):1234对应在线性地址中的位置，然后分页机制会将这个线性地址的前10bit用来索引页目录表，在页目录表中找到对应的目录项，通过查看页表项中的P标志位，看看映射的物理地址是否存在，存在就将其页表项提供的20bit基地址和线性地址的低12bit偏移地址合并起来得出物理地址，若不存在就先跑到磁盘去读出来，然后将上述的分页机制跑多一遍。  

虚拟地址（逻辑地址）

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/4.png)  

段选择符

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/5.png)  

段描述符

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/6.png)  

分页机制

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/7.png)  

页目录和页表项结构

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/8.png)


2、在任务A中，访问虚拟地址1234:5678，然后切换到任务B中，访问虚拟地址1234:5678，会发生什么事情呢？

在切换之前的操作和问题1的答案大同小异，然后当CPU从运行任务A切换到任务B的时候，LDT里面的内容就会被CPU或者操作系统改成任务B的映射关系，然后CPU或者操作系统通过段选择符的索引在改变后的LDT上面找到的段描述符，肯定就和之前任务A找到的不一样啦，导致任务B虽然与任务A用的虚拟地址是一样的，可是映射出来的线性地址不一样了。这样程序员写程序时候，在不同任务都能操作同一个虚拟地址，可是互相不影响。

## 4.5 保护

- 当程序对错误内存空间执行了一次非期望的引用，保护机制可以组织这种操作并报告此类事件。

### 4.5.1 段级保护

参考这个，很好很厉害：http://www.cnblogs.com/wanghj-dz/p/3987599.html

### 4.5.5 组合页级和段级保护

- 段级保护启动时候，页级保护只能在它的基础上再加一些保护，而不能抹掉原来的保护功能。

## 4.6 中断和异常处理

- 中断和异常是指明系统、处理器或当前执行程序（或任务）的某处出现一个事件，该事件需要处理器进行处理。

假设被中断的任务处于低特权级，而外部中断处理函数是个高特权级的非一致性代码段。那么当发生外部中断时候，CPU系统总线收到一个中断向量号（0~255），通过IDTR定位IDT表之后，将这个中断向量号*8得到一个在IDT上的索引号，然后在IDT中找出对应的中断门描述符，然后再用中断门描述符中的的段选择符在GDT或LDT中找到对应的段描述符，最后和IDT的中断门描述符的偏移值进行合并，得出线性地址。要是上述过程都通过了保护机制，而不发生错误的话，说明这次切换能够进行，由于是从低特权级到高特权级的非一致性程序段，CPU就会将DPL覆盖原来的CPL，会引发堆栈切换。所以首先要进行堆栈切换，然后再进行交换控制权。从DPL中，我们可以知道外部中断处理函数的特权级，然后就能在被中断任务的TSS中找出对应特权级的堆栈指针，先将当前的堆栈的指针临时保存起来，然后用TSS中找出的堆栈指针刷新堆栈寄存器。然后把刚刚临时保存的堆栈指针压入新栈，接着CPU又继续压了一堆信息进去新堆栈，最后把当前的CS：EIP的信息也压进去新栈。然后就可以交换控制权了，也就是开始运行外部中断函数的代码段，刚开始运行时候，外部中断的代码段可能会修改CS、DS等寄存器，可是堆栈用的还是刚刚被中断任务的TSS里面找出的堆栈指针开辟的堆栈空间。所以当需要返回被中断的任务时候用这个新堆栈就可以了，因为当时的堆栈和CS等寄存器信息都在这个新堆栈中。  

IDTR寄存器

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/9.png)  

中断门描述符格式  

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/10.png)

大概过程

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/3.png)

堆栈切换过程

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/2.png)

## 4.7 任务管理

- 当工作在保护模式下，处理器所有运行都在任务中。
- 当执行权传给“任务状态段描述符”或“任务门”时，就会造成任务切换。
- 当前运行任务的执行环境（称为上下文）。
- 一个任务由两部分构成：任务执行空间和任务状态段（TSS）。
任务执行空间包括代码段、堆栈段和一个或多个数据段。TSS指定了构成任务执行空间的各个段，并且为任务状态信息提供存储空间。

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/11.png)

- 一个任务使用指向其TSS的段选择符来指定。

### 4.7.3 任务管理数据结构

任务管理的数据结构：任务状态段TSS、TSS描述符、任务寄存器TR、任务门描述符。

#### 4.7.3.1 任务状态段：

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/12.png)

#### 4.7.3.2 TSS描述符：（只能存在GDT中）

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/13.png)

#### 4.7.3.3 任务寄存器：  

任务寄存器TR中存放着16bit的段选择符（可见部分）以及当前任务TSS段的整个描述符（不可见部分）。使用LTR指令将TSS段选择符赋值给TR寄存器的可见部分。

#### 4.7.3.4 任务门描述符：

任务门描述符中的TSS选择符字段指向GDT中的一个TSS段描述符。通过往TR寄存器的可见部分写入TSS段选择符，可以访问一个任务。通过CALL、JMP到一个门描述符的TSS段选择符也可以访问一个任务。

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/14.png)

### 4.7.4 任务切换

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/15.png)

当切换到一个新任务的时候，处理器会执行以下操作：  
1、从jmp等指令的**操作数**
或从**任务门**
或**TSS的前一任任务连接字段**取得新任务的TSS段选择符。  
2、检查当前任务是否允许切换到新任务（对JMP、CALL等指令应用特权级检查）。  
3、检查新任务的TSS描述符中是标注存在的（P=1）。  
4、改变旧任务下表中的部分标志位。（B、NT）  
5、把当前任务的状态保存在当前TSS中。  
6、改变新任务下表中的部分标志位。（NT、B）  
7、将新任务TSS的段选择符和描述符加载进任务寄存器TR（可见+不可见）。设置CR0寄存器的TS标志。  
8、把新任务的TSS状态加载新处理器。  
9、开始执行新任务。

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/第四章/picture/16.png)