#第三章 内核编程语言和环境

## 3.1 as86汇编器

- 它虽然可以为80386处理器编制32位代码，但是Linux系统仅用它来创建16位的启动引导扇区程序boot/bootsect.s和实模式下初始设置程序boot/setup.s的二进制执行码。
- 由于内核中的bootsec.s和setup.s程序都是单独编译链接的程序，所以生成的二进制文件没有和其他obj文件进行链接。

## 3.2 GNU as汇编

### 3.2.2 as汇编语法

- as使用AT&T语法，与Intel汇编语法不一样。 

![](3.png)

### 3.2.3 指令语句、操作数和寻址

- 一个间接操作数含有实际操作数值的地址值。（指针）
- 只有调转/调用指令才能使用间接操作数。

>下面对跳转指令的说明：

>- 立即操作数前需要加$

>- 寄存器名前需要加%

>- 内存操作数由变量名或者含有变量地址的一个寄存器指定。变量名隐含指出了变量地址，并指示CPU引用该地址处内存的内容。

#### 3.2.3.1 指令操作码的命名

- 符号扩展和零扩展指令都需要两个宽度来指明，即需要为源和目的操作数指明宽度。
AT&T是通过使用两个操作码后缀来做到，AT&T语法中符号扩展和零扩展的基本操作码名称分别是"movs"和"movz"。

>例如使用符号扩展从%al移动到%edx的AT&T语句是"movsbl %al,%edx"，即从byte到long是bl、从byte到word是bw、从word到long是wl。

#### 3.2.3.2 指令操作码前缀

- 操作码前缀用于修饰随后的操作码，它们用于重复字符串、提供区覆盖、执行总线锁定操作、或指定操作数和地址宽度。

>例如，串扫描指令“scas”使用前缀执行重复操作:  
repne scas %es:(%edi),%al
![](1.png)

#### 3.2.3.3 内存引用

-AT&T语法形式的内存引用例子：

![](2.png)

>参考下面链接来理解内存引用的含义：http://www.cnblogs.com/volcanol/archive/2011/09/24/2189690.html

#### 3.2.3.4 跳转指令

-  跳转指令用于把执行点转移到程序另一个位置处继续执行下去。这些跳转的目的位置通常使用一个标号来表示。
- 直接跳转指令：目标指令的地址是作为跳转指令的一部分直接编码进跳转指令中。
- 间接跳转指令：目的位置取自于某个寄存器或某个内存位置中。(必须使用星字符'*')

>jump NewLoc  #直接跳转。无条件跳转到标号NewLoc处继续执行。

>jmp *%eax    #间接跳转。寄存器%eax的值是跳转的目标位置。（指针）

>jmp *(%eax)  #间接跳转。从%eax指明的地址处读取跳转的目标位置。（双重指针）

### 3.2.4 区与重定位
