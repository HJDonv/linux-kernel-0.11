#第三章 内核编程语言和环境

## 3.1 as86汇编器

- 它虽然可以为80386处理器编制32位代码，但是Linux系统仅用它来创建16位的启动引导扇区程序boot/bootsect.s和实模式下初始设置程序boot/setup.s的二进制执行码。
- 由于内核中的bootsec.s和setup.s程序都是单独编译链接的程序，所以生成的二进制文件没有和其他obj文件进行链接。

## 3.2 GNU as汇编

### 3.2.2 as汇编语法

- as使用AT&T语法，与Intel汇编语法不一样。 

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/3.png)

### 3.2.3 指令语句、操作数和寻址

- 一个间接操作数含有实际操作数值的地址值。（指针）
- 只有调转/调用指令才能使用间接操作数。

>下面对跳转指令的说明：

>- 立即操作数前需要加$

>- 寄存器名前需要加%

>- 内存操作数由变量名或者含有变量地址的一个寄存器指定。变量名隐含指出了变量地址，并指示CPU引用该地址处内存的内容。

#### 3.2.3.1 指令操作码的命名

- 符号扩展和零扩展指令都需要两个宽度来指明，即需要为源和目的操作数指明宽度。AT&T是通过使用两个操作码后缀来做到，AT&T语法中符号扩展和零扩展的基本操作码名称分别是"movs"和"movz"。

>例如使用符号扩展从%al移动到%edx的AT&T语句是"movsbl %al,%edx"，即从byte到long是bl、从byte到word是bw、从word到long是wl。

#### 3.2.3.2 指令操作码前缀

- 操作码前缀用于修饰随后的操作码，它们用于重复字符串、提供区覆盖、执行总线锁定操作、或指定操作数和地址宽度。

>例如，串扫描指令“scas”使用前缀执行重复操作:  
repne scas %es:(%edi),%al

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/1.png)

#### 3.2.3.3 内存引用

- AT&T语法形式的内存引用例子：

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/2.png)

>参考下面链接来理解内存引用的含义：http://www.cnblogs.com/volcanol/archive/2011/09/24/2189690.html

#### 3.2.3.4 跳转指令

-  跳转指令用于把执行点转移到程序另一个位置处继续执行下去。这些跳转的目的位置通常使用一个标号来表示。
- 直接跳转指令：目标指令的地址是作为跳转指令的一部分直接编码进跳转指令中。
- 间接跳转指令：目的位置取自于某个寄存器或某个内存位置中。(必须使用星字符'*')

>jump NewLoc  #直接跳转。无条件跳转到标号NewLoc处继续执行。

>jmp *%eax    #间接跳转。寄存器%eax的值是跳转的目标位置。（指针）

>jmp *(%eax)  #间接跳转。从%eax指明的地址处读取跳转的目标位置。（双重指针）

### 3.2.4 区与重定位

- 区的概念主要用来表示编译器生成的目标文件（或可执行程序）中不同的信息区域，例如目标文件的正文区或数据区。
- 链接器ld会把输入的目标文件中内容按照一定的规律组合生成一个可执行程序。

> 目标文件中的代码被默认设置成从地址0开始，链接器会将目标文件的程序进行重定向，调整它们的地址。


#### 3.2.4、1 链接器涉及区

- 链接器ld只涉及4类区：text区、bss区、absolute区、undefined区。

>text、data区：当程序运行时，text区一般不会改变，text区通常会被进程共享，其中含代码和常数等内容，data区的内容一般会变，用来存变量。

>bss区：程序开始运行时，这个区的值是0。该区用来存放未初始化的变量或作为公共变量存储空间。在目标文件中，不保存bss区。

>absolute区：该区的地址“0”总是“重定位”到运行时刻的地址0处。

>undefined区：除了上面说到的区，其他用到的地址都是这个区的。

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/4.png)

#### 3.2.4.2 子区

- 有时候在汇编源程序某个区可能分布一些不相邻的数据组，但是你想让他们在目标文件中聚集在一起存放，就要用到as汇编器的子区概念。

>例如，编译器可能想把常数存放在text区中，但是不想让这些常数散布在被汇编的整个程序中，这种情况下，编译器就可以在每个会输出的代码区之前使用'.text 0'子区，并且在每组会输出的常数之前使用'.text 1'子区。

- 子区会以其从小到大的编号顺序出现在目标文件中，但是目标文件中并不包含表示子区的任何信息。

- 每个区（不是子区）都有一个位置计数器，它会对每个汇编进该区的字节进行计数。汇编指令'.align'可以改变其值，任何标号定义都会取用这个位置计数器的当前值。（用这个实现字节对齐）

### 3.2.5 符号

- 程序猿使用符号来命名对象，链接器使用符号进行链接操作，而调试器利用符号进行调试。
- 标号是后面紧跟一个冒号的符号。此时该符号代表活动位置计数器的（正在执行语句汇编处理的区的位置计数器）当前值，并且，例如可以作为指令的操作数使用。我们可以使用等号'='给一个符号赋予任意数值。 

#### 3.2.5.1 特殊点符号

- '.'表示as汇编的当前地址，因为表达式'mylab: .long .'就会把mylab定义为自己的地址值。

>'.long'是gas中用来定义一个长整型的存储空间的指令，一般是4字节。

#### 3.2.5.2 符号属性

- 除了名字以外，每个符号都有'值'和'类型'属性

>'值'通常是32位的，表示在text、data、bss或absolute区中一个位置的符号，其值是从区开始到标号所处位置的地址值。

>'类型'含有用于链接器和调试器的重定位信息、指示符号是外部的标志以及一些其他可选信息。对于a.out文件，类型属性存在一个8位字段中(n_type字节)。

### 3.2.6 as汇编命令

- 所有汇编命令的名称都以'.'开始，其余是字符，大小写都可以，一般用小写。

#### 3.2.6.1 .align abs-expr1,abs-expr2,abs-expr3
  
>.ailgn是存储对齐汇编指令，用于在当前子区中把位置计数器值增加到下一个指定存储边界处。  
abs-expr1指定要求的边界对齐值，对于使用a.out格式的80x86系统，该值应该是2的次方值，例如.align 3表示把位置计数器增加到8的倍数，但是对于使用ELF格式的80x86，该表达式的值直接就是要求对齐的字节数，例如.align 8表示把位置计数器增加到8的倍数。  
abs-expr2用于对齐而填充的字节数。  
abs-expr3指示对齐操作允许填充跳过的最大字节数。

### 3.2.7 编写16位代码

- 一般as用来写纯32位的80x86代码，但是1995年后它对编写运行于实模式或16位保护模式的代码也提供有限的支持。为了让as产生16位代码，需要再运行16位模式的指令语句之前添加汇编命令'.code16'，并且使用'.code32'切换回32位代码汇编方式。

>as运行于16位模式实质就是为指令添加了额外的地址和操作数宽度前缀，所以汇编产生的代码长度和性能上将会受到影响。

- 1991年发布的linux0.11，那时候as还不支持16位代码，所以在编写和汇编0.11的内核实模式下的引导启动代码和初始化汇编程序使用了前面的as86汇编器。

#3.3 C语言程序