#第三章 内核编程语言和环境

## 3.1 as86汇编器

- 它虽然可以为80386处理器编制32位代码，但是Linux系统仅用它来创建16位的启动引导扇区程序boot/bootsect.s和实模式下初始设置程序boot/setup.s的二进制执行码。
- 由于内核中的bootsec.s和setup.s程序都是单独编译链接的程序，所以生成的二进制文件没有和其他obj文件进行链接。

## 3.2 GNU as汇编

### 3.2.2 as汇编语法

- as使用AT&T语法，与Intel汇编语法不一样。 

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/3.png)

### 3.2.3 指令语句、操作数和寻址

- 一个间接操作数含有实际操作数值的地址值。（指针）
- 只有调转/调用指令才能使用间接操作数。

>下面对跳转指令的说明：

>- 立即操作数前需要加$

>- 寄存器名前需要加%

>- 内存操作数由变量名或者含有变量地址的一个寄存器指定。变量名隐含指出了变量地址，并指示CPU引用该地址处内存的内容。

#### 3.2.3.1 指令操作码的命名

- 符号扩展和零扩展指令都需要两个宽度来指明，即需要为源和目的操作数指明宽度。AT&T是通过使用两个操作码后缀来做到，AT&T语法中符号扩展和零扩展的基本操作码名称分别是"movs"和"movz"。

>例如使用符号扩展从%al移动到%edx的AT&T语句是"movsbl %al,%edx"，即从byte到long是bl、从byte到word是bw、从word到long是wl。

#### 3.2.3.2 指令操作码前缀

- 操作码前缀用于修饰随后的操作码，它们用于重复字符串、提供区覆盖、执行总线锁定操作、或指定操作数和地址宽度。

>例如，串扫描指令“scas”使用前缀执行重复操作:  
repne scas %es:(%edi),%al

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/1.png)

#### 3.2.3.3 内存引用

- AT&T语法形式的内存引用例子：

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/2.png)

>参考下面链接来理解内存引用的含义：http://www.cnblogs.com/volcanol/archive/2011/09/24/2189690.html

#### 3.2.3.4 跳转指令

-  跳转指令用于把执行点转移到程序另一个位置处继续执行下去。这些跳转的目的位置通常使用一个标号来表示。
- 直接跳转指令：目标指令的地址是作为跳转指令的一部分直接编码进跳转指令中。
- 间接跳转指令：目的位置取自于某个寄存器或某个内存位置中。(必须使用星字符'*')

>jump NewLoc  #直接跳转。无条件跳转到标号NewLoc处继续执行。

>jmp *%eax    #间接跳转。寄存器%eax的值是跳转的目标位置。（指针）

>jmp *(%eax)  #间接跳转。从%eax指明的地址处读取跳转的目标位置。（双重指针）

### 3.2.4 区与重定位

- 区的概念主要用来表示编译器生成的目标文件（或可执行程序）中不同的信息区域，例如目标文件的正文区或数据区。
- 链接器ld会把输入的目标文件中内容按照一定的规律组合生成一个可执行程序。

> 目标文件中的代码被默认设置成从地址0开始，链接器会将目标文件的程序进行重定向，调整它们的地址。


#### 3.2.4、1 链接器涉及区

- 链接器ld只涉及4类区：text区、bss区、absolute区、undefined区。

>text、data区：当程序运行时，text区一般不会改变，text区通常会被进程共享，其中含代码和常数等内容，data区的内容一般会变，用来存变量。

>bss区：程序开始运行时，这个区的值是0。该区用来存放未初始化的变量或作为公共变量存储空间。在目标文件中，不保存bss区。

>absolute区：该区的地址“0”总是“重定位”到运行时刻的地址0处。

>undefined区：除了上面说到的区，其他用到的地址都是这个区的。

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/4.png)

#### 3.2.4.2 子区

- 有时候在汇编源程序某个区可能分布一些不相邻的数据组，但是你想让他们在目标文件中聚集在一起存放，就要用到as汇编器的子区概念。

>例如，编译器可能想把常数存放在text区中，但是不想让这些常数散布在被汇编的整个程序中，这种情况下，编译器就可以在每个会输出的代码区之前使用'.text 0'子区，并且在每组会输出的常数之前使用'.text 1'子区。

- 子区会以其从小到大的编号顺序出现在目标文件中，但是目标文件中并不包含表示子区的任何信息。

- 每个区（不是子区）都有一个位置计数器，它会对每个汇编进该区的字节进行计数。汇编指令'.align'可以改变其值，任何标号定义都会取用这个位置计数器的当前值。（用这个实现字节对齐）

### 3.2.5 符号

- 程序猿使用符号来命名对象，链接器使用符号进行链接操作，而调试器利用符号进行调试。
- 标号是后面紧跟一个冒号的符号。此时该符号代表活动位置计数器的（正在执行语句汇编处理的区的位置计数器）当前值，并且，例如可以作为指令的操作数使用。我们可以使用等号'='给一个符号赋予任意数值。 

#### 3.2.5.1 特殊点符号

- '.'表示as汇编的当前地址，因为表达式'mylab: .long .'就会把mylab定义为自己的地址值。

>'.long'是gas中用来定义一个长整型的存储空间的指令，一般是4字节。

#### 3.2.5.2 符号属性

- 除了名字以外，每个符号都有'值'和'类型'属性

>'值'通常是32位的，表示在text、data、bss或absolute区中一个位置的符号，其值是从区开始到标号所处位置的地址值。

>'类型'含有用于链接器和调试器的重定位信息、指示符号是外部的标志以及一些其他可选信息。对于a.out文件，类型属性存在一个8位字段中(n_type字节)。

### 3.2.6 as汇编命令

- 所有汇编命令的名称都以'.'开始，其余是字符，大小写都可以，一般用小写。

#### 3.2.6.1 .align abs-expr1,abs-expr2,abs-expr3
  
>.ailgn是存储对齐汇编指令，用于在当前子区中把位置计数器值增加到下一个指定存储边界处。  
abs-expr1指定要求的边界对齐值，对于使用a.out格式的80x86系统，该值应该是2的次方值，例如.align 3表示把位置计数器增加到8的倍数，但是对于使用ELF格式的80x86，该表达式的值直接就是要求对齐的字节数，例如.align 8表示把位置计数器增加到8的倍数。  
abs-expr2用于对齐而填充的字节数。  
abs-expr3指示对齐操作允许填充跳过的最大字节数。

### 3.2.7 编写16位代码

- 一般as用来写纯32位的80x86代码，但是1995年后它对编写运行于实模式或16位保护模式的代码也提供有限的支持。为了让as产生16位代码，需要再运行16位模式的指令语句之前添加汇编命令'.code16'，并且使用'.code32'切换回32位代码汇编方式。

>as运行于16位模式实质就是为指令添加了额外的地址和操作数宽度前缀，所以汇编产生的代码长度和性能上将会受到影响。

- 1991年发布的linux0.11，那时候as还不支持16位代码，所以在编写和汇编0.11的内核实模式下的引导启动代码和初始化汇编程序使用了前面的as86汇编器。

##3.3 C语言程序

### 3.3.2 嵌入汇编（内联汇编）

	具有输入和输出参数的内联汇编一般格式:
	asm("汇编语句"
		:输出寄存器
		:输入寄存器
		:会被修改的寄存器)；


![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/8.png)


----------

- CLD指令功能：将标志寄存器Flag的方向标志位DF清零。在字串操作中使变址寄存器SI或DI的地址指针自动往高地址增加，字串处理由前往后。  


例如，以下三条指令执行后，SI自动加1，更新0001H：

	CLD
	MOV SI，0000H
	LODSB ;将字串中的SI指针所指的一个字节装入AL

又如，以下三条指令执行后，SI自动加2，更新为0102H：  

	CLD
	MOV SI，0100H
	LODSW ;将字串中的SI指针所指的一个字(双字节)装入AX


［知识引伸］：
相反功能指令是STD，将方向标志位DF置1，
在字串操作中使SI或DI的地址指针自动往低地址递减，字串处理由后往前。

----------

- 跳转指令(跳转标号的后缀：f——表示跳转方向是还未运行的程序，b——表示跳转方向是已经运行过的程序)  
一、无条件跳转: JMP  
二、根据 CX、ECX 寄存器的值跳转: JCXZ(CX 为 0 则跳转)、JECXZ(ECX 为 0 则跳转)  
三、根据 EFLAGS 寄存器的标志位跳转, 这个太多了.  

根据标志位跳转的指令:  
JE   ;等于则跳转  
JNE  ;不等于则跳转  
JZ   ;为 0 则跳转  
JNZ  ;不为 0 则跳转  
JS   ;为负则跳转  
JNS  ;不为负则跳转  
JC   ;进位则跳转   
JNC  ;不进位则跳转    
JO   ;溢出则跳转   
JNO  ;不溢出则跳转    
JA   ;无符号大于则跳转   
JNA  ;无符号不大于则跳转   
JAE  ;无符号大于等于则跳转   
JNAE ;无符号不大于等于则跳转    
JG   ;有符号大于则跳转   
JNG  ;有符号不大于则跳转   
JGE  ;有符号大于等于则跳转   
JNGE ;有符号不大于等于则跳转    
JB   ;无符号小于则跳转   
JNB  ;无符号不小于则跳转   
JBE  ;无符号小于等于则跳转   
JNBE ;无符号不小于等于则跳转    
JL   ;有符号小于则跳转   
JNL  ;有符号不小于则跳转  
JLE  ;有符号小于等于则跳转  
JNLE ;有符号不小于等于则跳转  
JP   ;奇偶位置位则跳转 

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/5.png)



----------

- SCASB的作用:  
对于字节串，执行（AL）-(DI)；根据执行结果设置状态位，但执行结果不改变DI所指向的内存单元的值。根据DF的值及使用的指令是SCASB修改SI和DI，使SI和DI指向串处理方向的下一个元素。

----------


- LODSB/LODSW  
汇编语言中，串操作指令LODSB/LODSW是块装入指令，其具体操作是把SI指向的存储单元读入累加器，LODSB就读入AL，LODSW就读入AX中，然后SI自动增加或减小1或2。其常常是对数组或字符串中的元素逐个进行处理。

### 3.3.4 寄存器变量

在GNU C程序中我们定义一个局部寄存器变量：

	register int res _asm_("ax");

gcc不保证编译出的代码会把变量一直放在指定的寄存器中，因此最好不要明确地引用该寄存器并且假设该寄存器肯定引用的是该变量值，然而把该变量用作为asm操作数还是能够保证指定的寄存器被用作该操作数。（操作res的时候一定是操作ax，操作ax时候不一定是操作res）

### 3.3.5 内联函数

- 在程序中，通过把一个函数声明为内联函数，就可以让gcc把函数的代码集成到调用该函数的代码中。  

>inline函数使用或者不使用static与extern的作用:  
>  
>  1、有static，如果对该内联函数的调用都能被替换而集成在调用者代码中，并且程序中没有引用过该函数的地址，那么gcc不会为该函数自身生成代码。如果存在一个不能被替换集成的调用或者程序中有调用了该函数地址，那么就生成函数汇编代码。  
>  2、无static，gcc认为其他程序文件对这个函数有调用，因此总是会被编译出自己的汇编代码来。  
>  3、有extern，类似于个宏定义，那么该函数仅用于内联集成，并且在任何情况都不会单独产生自身的汇编代码。使用这种组合方式就是把带有inline和extern两个组合关键词的函数定义放在.h文件中，并且把不含关键词的另一个相同函数定义放在一个库文件中。此时头文件中的定义会让绝大多数对该函数的调用被替换嵌入，如果还有该函数没被替换的调用，就引用库文件或程序中的定义。

## 3.4 C与汇编程序的相互调用

### 3.4.1 C函数调用机制

- 函数调用操作包括从一块代码到另一块代码之间的__双向数据传递__和**执行控制转移**。
Intel 80X86 CPU为控制传递提供简单的指令，而数据的传递和局部变量的存储空间分配与回收则通过栈操作来实现。

#### 3.4.1.1 栈帧结构和控制转移权方式

- 调用函数时候需要遵守的Intel CPU惯例。

>寄存器eax，edx和ecx的内容必须由调用者自己负责保存。
也就是在调用时候，调用者要将这几个寄存器进行压栈操作，然后再跳到被调用者的程序中，这样被调用者怎么操作这几个寄存器都不会破坏原来的寄存器内容。

>寄存器ebx，esi，ebp，esp和edi的内容必须由被调用者负责保护。  
也就是被调用者开始运行的时候，就要先把这几个寄存器进行压栈操作，然后再使用这些寄存器就不会破坏原来的寄存器内容了。

#### 3.4.1.2 函数调用举例

	void swap(int *a,int *b)
	{
		int c;
		c = *a; *a = *b; *b = c;	
	}

	int main()
	{
		int a,b;
		a = 16;b=32;
        swap(&a,&b);
		return (a-b);
	}

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/6.png)

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/7.png)

## 3.5 Linux 0.11目标文件格式

### 3.5.1 目标文件格式

- linux 0.11用的是传统的a.out格式，对于具有内存分页机制的系统来说，这是一种简单有效的目标文件格式。

![](https://raw.githubusercontent.com/HJDonv/linux-kernel-0.11/master/%E7%AC%AC%E4%B8%89%E7%AB%A0/picture/9.png)

### 3.5.2 linux 0.11目标文件格式

看完第四章再回来看。

### 3.5.3 链接程序输出

- 链接程序的首要任务是给执行文件（或者输出的模块文件）进行存储空间分配操作。